package fiji.plugin.maars.cellstateanalysis;

import java.io.FileNotFoundException;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Random;

import org.micromanager.internal.utils.ReportingUtils;

import ij.ImagePlus;
import ij.gui.Roi;
import ij.measure.ResultsTable;
import ij.plugin.frame.RoiManager;

/**
 * Class to manipulate a set of cells which corresponds to cells of one field
 * 
 * @author marie
 *
 */
public class SetOfCells implements Iterable<Cell>, Iterator<Cell> {
	// tools to get results
	private RoiManager roiManager;
	private Roi[] roiArray;
	private int count = 0;
	private ResultsTable rt;

	// Inputs
	private String pathToRois;
	private ImagePlus bfImage;
	private ArrayList<Cell> cellArray;

	// output
	private String pathToSaveResults;

	/**
	 * Constructor 1:
	 * 
	 * @param bfImage
	 *            : image containing cells of the set (segmentation was realised
	 *            on this image)
	 * @param fluoImage
	 *            : fluorescent image used to find which cell are in a mitotic
	 *            state
	 * @param correaltionImage
	 *            : correlation image generated by segmentation process
	 * @param focusSlice
	 *            : slice number correponding to focus plane in bfImage
	 * @param direction
	 *            : -1 -> cell bounds are black then white 1 -> cell bounds are
	 *            white then black
	 * @param pathToRois
	 *            : path allowing to get ROIs generated by segmntation process
	 * @param pathToSaveResults
	 *            : path indicating where results of analysis should be stored
	 */
	public SetOfCells(ImagePlus bfImage, ImagePlus fluoImage, int focusSlice,
			String pathToRois, String pathToSaveResults) {

		try {
			PrintStream ps = new PrintStream(pathToSaveResults
					+ bfImage.getShortTitle() + "_CellStateAnalysis.LOG");
			System.setOut(ps);
			System.setErr(ps);
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}

		ReportingUtils.logMessage("Set of cells with fluorescent image :");
		ReportingUtils.logMessage("Get all parameters ...");
		this.bfImage = bfImage;
		this.pathToRois = pathToRois;
		this.pathToSaveResults = pathToSaveResults;
		ReportingUtils.logMessage("Done");
		ReportingUtils.logMessage("create result table");
		rt = new ResultsTable();
		ReportingUtils.logMessage("Done");

		ReportingUtils.logMessage("Get ROIs as array");
		roiArray = getRoisAsArray();
		cellArray = new ArrayList<Cell>();
		ReportingUtils.logMessage("Initialize Cells in array");
		for (int i = 0; i < roiArray.length; i++) {
			cellArray.add(i, new Cell(bfImage, fluoImage, focusSlice,
					roiArray[i], i, rt));
		}
		ReportingUtils.logMessage("Done.");
	}

	/**
	 * Constructor 2:
	 * 
	 * @param bfImage
	 *            : image containing cells of the set (segmentation was realised
	 *            on this image)
	 * @param correaltionImage
	 *            : correlation image generated by segmentation process
	 * @param focusSlice
	 *            : slice number correponding to focus plane in bfImage
	 * @param direction
	 *            : -1 -> cell bounds are black then white 1 -> cell bounds are
	 *            white then black
	 * @param pathToRois
	 *            : path allowing to get ROIs generated by segmntation process
	 * @param pathToSaveResults
	 *            : path indicating where results of analysis should be stored
	 */
	public SetOfCells(ImagePlus bfImage, int focusSlice, String pathToRois,
			String pathToSaveResults) {

		try {
			PrintStream ps = new PrintStream(pathToSaveResults
					+ bfImage.getShortTitle() + "_CellStateAnalysis.LOG");
			System.setOut(ps);
			System.setErr(ps);
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}

		ReportingUtils.logMessage("Set of cells without fluorescent image :");
		ReportingUtils.logMessage("Get all parameters ...");
		this.bfImage = bfImage;
		this.pathToRois = pathToRois;
		this.pathToSaveResults = pathToSaveResults;
		ReportingUtils.logMessage("Done");
		ReportingUtils.logMessage("create result table");
		rt = new ResultsTable();
		ReportingUtils.logMessage("Done");

		ReportingUtils.logMessage("Get ROIs as array");
		roiArray = getRoisAsArray();
		cellArray = new ArrayList<Cell>();
		ReportingUtils.logMessage("Initialize Cells in array");
		for (int i = 0; i < roiArray.length; i++) {
			cellArray.add(i, new Cell(bfImage, focusSlice, roiArray[i], i, rt));
		}
		ReportingUtils.logMessage("Done.");
	}

	/**
	 * Constructor 3:
	 * 
	 * @param cellArray
	 *            : array of cell
	 */
	public SetOfCells(ArrayList<Cell> cellArray) {
		this.cellArray = cellArray;
	}

	/**
	 * Method to shuffle set of cell (put them in random order)
	 */
	public void shuffle() {

		int n = length();
		Random random = new Random();

		for (int i = 0; i < n; i++) {
			int newPosition = i + random.nextInt(n - i);
			Cell cellTemp = cellArray.get(i);
			cellArray.remove(i);
			cellArray.add(i, cellArray.get(newPosition));
			cellArray.remove(newPosition);
			cellArray.add(newPosition, cellTemp);
		}
	}

	/**
	 * Method to open ROI file and get them as ROI array
	 * 
	 * @return
	 */
	public Roi[] getRoisAsArray() {

		roiManager = RoiManager.getInstance();
		if (roiManager == null) {
			roiManager = new RoiManager();
			roiManager.runCommand("Open", pathToRois);
		}
		return roiManager.getRoisAsArray();
	}

	/**
	 * Closes RoiManager
	 */
	public void closeRoiManager() {
		roiManager.close();
	}

	/**
	 * Method to get Cell corresponding to index
	 * 
	 * @param index
	 * @return Cell corresponding to index
	 */
	public Cell getCell(int index) {
		return cellArray.get(index);
	}

	/**
	 * Method to get Cell index using coordinates of centroid
	 * 
	 * @param xCentroid
	 * @param yCentroid
	 * @return index of cell if there is any, -1 otherwise
	 */
	public int getCellIndex(double xCentroid, double yCentroid) {
		int index = 0;
		for (Cell cell : cellArray) {
			if (cell.getMeasures().getXCentroid() == xCentroid
					&& cell.getMeasures().getYCentroid() == yCentroid) {
				return cell.getCellNumber();
			}
		}
		return index;
	}

	/**
	 * 
	 * @return image used for segmentation
	 */
	public ImagePlus getBFImage() {
		return bfImage;
	}

	/**
	 * 
	 * @return array length
	 */
	public int length() {
		return cellArray.size();
	}

	/**
	 * 
	 * @return path where results are stored
	 */
	public String getPath() {
		return pathToSaveResults;
	}

	/**
	 * 
	 * @return path where results are stored
	 */
	public RoiManager getROIManager() {
		return this.roiManager;
	}

	@Override
	public Iterator<Cell> iterator() {
		resetCount();
		return this;
	}

	@Override
	public boolean hasNext() {
		if (count < cellArray.size()) {
			return true;
		}
		return false;
	}

	@Override
	public Cell next() {
		if (count == cellArray.size())
			throw new NoSuchElementException();
		count++;
		return cellArray.get(count - 1);
	}

	@Override
	public void remove() {
		throw new UnsupportedOperationException();

	}

	public void resetCount() {
		this.count = 0;
	}

}
