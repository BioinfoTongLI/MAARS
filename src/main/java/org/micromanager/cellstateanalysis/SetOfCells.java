package org.micromanager.cellstateanalysis;

import java.io.FileNotFoundException;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Random;

import org.micromanager.internal.utils.ReportingUtils;
import org.micromanager.segmentPombe.SegPombeParameters;

import ij.ImagePlus;
import ij.gui.Roi;
import ij.measure.ResultsTable;
import ij.plugin.frame.RoiManager;

/**
 * Class to manipulate a set of cells which corresponds to cells of one field
 * 
 * @author Tong LI && marie
 *
 */
public class SetOfCells implements Iterable<Cell>, Iterator<Cell> {
	// tools to get results
	private RoiManager roiManager;
	private Roi[] roiArray;
	private int count = 0;
	private ResultsTable rt;

	private ArrayList<Cell> cellArray;

	/**
	 * Constructor
	 * 
	 * @param bfImage
	 *            : image containing cells of the set (segmentation was realized
	 *            on this image)
	 * @param correaltionImage
	 *            : correlation image generated by segmentation process
	 * @param focusSlice
	 *            : slice number corresponding to focus plane in bfImage
	 * @param direction
	 *            : -1 -> cell bounds are black then white 1 -> cell bounds are
	 *            white then black
	 * @param pathToRois
	 *            : path allowing to get ROIs generated by segmentation process
	 * @param pathToSaveResults
	 *            : path indicating where results of analysis should be stored
	 */
	public SetOfCells(SegPombeParameters parameters) {
		try {
			PrintStream ps = new PrintStream(parameters.getSavingPath()
					+ "CellStateAnalysis.LOG");
			System.setOut(ps);
			System.setErr(ps);
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}
		// rt will be reset after analysis of each cell
		rt = new ResultsTable();
		ReportingUtils.logMessage("Get ROIs as array");
		roiArray = getRoisAsArray(parameters.getSavingPath()
				+ parameters.getImageToAnalyze().getShortTitle() + "_ROI.zip");
		cellArray = new ArrayList<Cell>();
		ReportingUtils.logMessage("Initialize Cells in array");
		for (int i = 0; i < roiArray.length; i++) {
			cellArray.add(i, new Cell(roiArray[i], i, rt));
		}
		ReportingUtils.logMessage("Done.");
	}

	/**
	 * Method to shuffle set of cell (put them in random order)
	 */
	public void shuffle() {

		int n = cellArray.size();
		Random random = new Random();

		for (int i = 0; i < n; i++) {
			int newPosition = i + random.nextInt(n - i);
			Cell cellTemp = cellArray.get(i);
			cellArray.remove(i);
			cellArray.add(i, cellArray.get(newPosition));
			cellArray.remove(newPosition);
			cellArray.add(newPosition, cellTemp);
		}
	}

	/**
	 * Method to open ROI file and get them as ROI array
	 * 
	 * @return
	 */
	public Roi[] getRoisAsArray(String pathToRois) {

		roiManager = RoiManager.getInstance();
		if (roiManager == null) {
			roiManager = new RoiManager();
			roiManager.runCommand("Open", pathToRois);
		}
		return roiManager.getRoisAsArray();
	}

	/**
	 * Closes RoiManager
	 */
	public void closeRoiManager() {
		roiManager.close();
	}

	/**
	 * Method to get Cell corresponding to index
	 * 
	 * @param index
	 * @return Cell corresponding to index
	 */
	public Cell getCell(int index) {
		return cellArray.get(index);
	}

	public RoiManager getROIManager() {
		return this.roiManager;
	}

	// iterator related
	@Override
	public Iterator<Cell> iterator() {
		resetCount();
		return this;
	}

	@Override
	public boolean hasNext() {
		if (count < cellArray.size()) {
			return true;
		}
		return false;
	}

	@Override
	public Cell next() {
		if (count == cellArray.size())
			throw new NoSuchElementException();
		count++;
		return cellArray.get(count - 1);
	}

	@Override
	public void remove() {
		throw new UnsupportedOperationException();

	}

	public void resetCount() {
		this.count = 0;
	}

}
